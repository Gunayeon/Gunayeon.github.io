## Argorithm

___
```markdown
input---->Argorithm---->output
```
___
#### Analysis
```markdown
- Space complexity
- Time complexity
```

___
#### poluminal time
```markdown
ex) input=3 -> complexity=9
    input=9 -> complexity=81

    ->input=n -> complexity=n^2n
```
 이렇게 input이 n일떄, 복잡도가 다항식으로 나타나는 것을 다항시간(polunominal time)이라고 한다.

 만약 알고리즘이 복잡해지게 되면 complexity가 다항식이 아닌 지수식으로 증가하는 문제가 생긴다.
 
 ```markdown
 ex) 3-->3^n
     9-->9^n
```
이러한 문제가 생기면 시간이 오래걸리는 단점이 있다.

___
#### Example(보따리)

1번부터 10번이 적혀있는 보따리에 금화가 10개씩 들어있다. 가짜금이 진짜금보다 1g 적게나간다고 한다.

* 풀이1
> 저울에 보따리를 한번씩 다 재본다.(n번)->평균적으로 n/2번 만큼 서치를 하면 가짜금화가 찾아진다.


* 풀이2
>보따리 10개를 절반씩 나누어 한세트를 이루게 한다.  무게오차가 있을 때까지 보따리세트를 또 절반씩 나누어 재고 오차가 생기면 하나씩 재본다. 

* 풀이3
> 각 보따리에 적혀있는 번호수만큼 금화를 뺴낸다. 진짜금화가 2g이라고 치면 원래는 55X2=110g이어야 하는데 10g이 부족하다면 10번보따리에 가짜 금화가 들어있는 것이다.


->같은 문제라도 어떻게 알고리즘을 구성하냐에 따라 시간복잡도가 달라진다.

->시간복잡도가 낮은 알고리즘은 공간복잡도가 높다.

___
#### Time complexity

* O(n)  (Big-O)
> O(g(n))={f(n)|∃c>0,n0>0 s.t ∀ n>=n0, f(n)<=g(n)}

> 용어정리
 ∃:exist를 표현 \
s.t:~에 대해서\
∀:for all


> O(n) -> 점근적상한

* Ω((n))
> Ω(g(n))={f(n)|∃c>0,n0>0 s.t ∀ n>=n0, cf(n)<=g(n)}

> Ω((n))->점근적하한

* θ(n)
>θ(g(n))={f(n)|∃c1,c2>0,n0>0 s.t ∀ n>=n0, c1f(n)<=g(n)<= c2f(n)}

> 알고리즘 성능을 나타낼 때 하한을 낯춰서 설명할 수도 있고 상한을 높여서 설명할 수도 있음 -> 모호해질 수 있음 -> 범위를 좁혀서 나타내게 함
